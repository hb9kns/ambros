#!/bin/sh
# extractor <prefix> <reportfile> <source1> <source2> ...
# must be run in directory of sources
# will process each source according to its configuration file
# and save new clean text (if available) in same directory
# with <prefix> as start of name and <reportfile> for reporting
# time of earliest next polling (for job planning) and other information

# read global settings
. $SCRIPTDIR/constants.sh
tmpf=$TMPDIR/extractor.tmp

minpoll=${MAXPOLLING:-999999}
starttime=`nowsec`

echo $0 working:

# only one character for prefix
prefix=`echo $1 | sed -e 's/\(.\).*/\1/'`
reportfile=$2
shift 2
suffix=${SOURCEFILESUFFIX:-.txt}

logf=`logfile extractor-$prefix`

for source in $*
do echo :$source
 cd $source
# ignore directories without readable configuration file
 if test -r $SOURCECONFIG
 then
# read status values or set default ones
  if test -r $SOURCESTATUS
  then
   index=`configread $SOURCESTATUS INDEX`
   lasthash=`configread $SOURCESTATUS LASTHASH`
   lastpoll=`configread $SOURCESTATUS LASTPOLL`
  fi
# for index, use source configuration or global start value
  index=${index:-`configread $SOURCECONFIG MININDEX`}
  index=${index:-SOURCEINDEXSTART}
  lasthash=${lasthash:-nil}
  lastpoll=${lastpoll:-0}
  now=`nowsec`
# get polling interval, set to maximum if unset
  polling=`configread $SOURCECONFIG POLLING` || polling=$MAXPOLLING
# calculate time of next polling
  polling=`expr $lastpoll + $polling - $now`
# poll if passed
  if test $polling -le 0
  then
   logit $logf $source now polling
# source descriptor (url, file, etc)
   desc=`configread $SOURCECONFIG SOURCE` || desc=file:///dev/null
   prio=`configread $SOURCECONFIG PRIORITY` || prio=$DEFAULTPRIORITY
   recipe=`configread $SOURCECONFIG RECIPE`
   if test ! -x "$recipe"
   then
    logit $logf $source ignoring non-executable recipe $recipe
    recipe=/bin/cat
   fi
# store headers for further processing
   cat <<EOH >$tmpf
IDENTIFICATION	$desc
PRIORITY	$prio
INDEX	$index
DECAY	$decay
EOH
   if $SCRIPTDIR/fetcher "$desc" >> $tmpf
   then
    stname="$prefix$prio$index$suffix"
   else logit $logf $source fetching or filtering failed
   fi
# re-read polling interval
   polling=`configread $SOURCECONFIG POLLING` || polling=$MAXPOLLING
  fi
# calculate minimal future polling time
  if test $minpoll -lt $polling
  then minpoll=$polling
  fi
# save current status
  cat <<EOT >$SOURCESTATUS
INDEX		$index
LASTHASH	$lasthash
LASTPOLL	$now
EOT
 else logit $logf $source no configfile found, ignoring
 fi
# go back to channel directory
 cd ..
done

# save closest next polling time for controller
echo NEXTPOLL `expr $starttime + $minpoll` > $reportfile
rm -f $tmpf
